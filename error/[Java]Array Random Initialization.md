# Java 数组随机初始化“永远只生成固定长度数组”问题分析与解决

## 一、问题现象
在编写 Java 代码实现 “生成随机长度数组 + 随机数初始化” 功能时，出现两处核心异常，代码功能意图与实际执行结果不符：
- 功能意图：
    - 生成两个长度为 5-10 之间（不含5和10）随机数的数组，并用 0-99 的随机整数初始化数组元素
    - 生成第三个长度为前两个数组长度之和的数组，通过System.arraycopy合并前两个数组到第三个数组中
- 实际异常表现：
    - 数组长度异常：lengthA/lengthB永远固定为 6，无法生成 5-10 之间的随机长度
    - 数组元素异常：若初始化语句写为(int)Math.random() * 100，数组元素值永远为 0，无法生成 0-99 的随机数
- 核心错误代码片段：
    ```java
    // 错误1：数组长度永远为6
    int lengthA = 6 + (int)Math.random() * 4;
    // 错误2：数组元素永远为0
    b[i] = (int)Math.random() * 100;
    ```

## 二、报错核心原因
- 错误 1：数组长度固定的核心原因
    - Java 中强制类型转换`(int)的优先级高于乘法*`，乘法优先级高于加法+，且`Math.random()方法返回值范围是 0.0 ≤ x < 1.0`
    - 执行逻辑：(int)Math.random() 会直接截断 0.0~1.0 之间小数的小数部分，结果永远为 0
    - 后续运算：0 * 4 = 0，最终 6 + 0 = 6，因此数组长度固定为 6，完全失去随机性
- 错误 2：数组元素永远为 0 的核心原因
    - 同样`因运算优先级`规则导致：
    - (int)Math.random() 结果恒为 0（原因同上）
    - 后续乘法运算：0 * 100 = 0，因此数组元素被赋值为 0，无法生成 0-99 的随机数

# 三、解决方案
- 核心思路
    
    先完成 `“基础值 + 随机数范围” 的整体`计算，再对结果强制类型转换，确保随机数范围生效

    ```java
    // 生成[5,10]范围随机整数公式：(int)(min + Math.random() * (max - min + 1))
    int lengthA = (int)(5 + Math.random() * 6);
    int lengthB = (int)(5 + Math.random() * 6);

    b[i] = (int)(Math.random() * 100);
    ```

# 四、注意
- `强转int`会直接舍弃小数部分（`无四舍五入`）
- System.arraycopy 需注意目标数组的起始索引（`第二个数组的起始索引为第一个数组的长度`），避免元素覆盖。